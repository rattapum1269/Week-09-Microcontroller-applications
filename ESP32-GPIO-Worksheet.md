# ЁЯзк ESP32 GPIO Lab Worksheet

## ЁЯОп р╕зр╕▒р╕Хр╕Цр╕╕р╕Ыр╕гр╕░р╕кр╕Зр╕Др╣М

р╕лр╕ер╕▒р╕Зр╕Ир╕▓р╕Бр╕Чр╕│ Lab р╕Щр╕╡р╣Йр╣Бр╕ер╣Йр╕з р╕Ьр╕╣р╣Йр╣Ар╕гр╕╡р╕вр╕Щр╕Ир╕░р╕кр╕▓р╕бр╕▓р╕гр╕Ц:

1. р╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕нр╕зр╕Зр╕Ир╕г LED р╕Бр╕▒р╕Ъ ESP32 GPIO
2. р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щр╕Вр╕нр╕З GPIO Data Flow
3. р╣Ар╕Вр╕╡р╕вр╕Щр╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕бр╕Др╕зр╕Ър╕Др╕╕р╕б LED р╣Бр╕Ър╕Ъ step-by-step
4. р╣Гр╕Кр╣Й ESP-IDF API р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕Др╕зр╕Ър╕Др╕╕р╕б GPIO

---

## ЁЯФз Lab 1: р╕Бр╕▓р╕гр╕Др╕зр╕Ър╕Др╕╕р╕б LED р╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щ

### тЪб Hardware Setup

#### ЁЯУК LED Circuit### ЁЯФз Complete Implementation Example

**р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ьр╕╣р╣Йр╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╕Фр╕╣ code р╣Бр╕Ър╕Ър╕кр╕бр╕Ър╕╣р╕гр╕Ур╣Мр╕Чр╕╡р╣Ир╣Гр╕Кр╣Й FreeRTOS Task р╣Бр╕ер╕░ proper structure:**



![LED Circuit](images/led_circuit.svg)

#### ЁЯзо р╕Бр╕▓р╕гр╕Др╕│р╕Щр╕зр╕Ур╕Др╣Ир╕▓ Resistor

``` cagram
```
**р╕Бр╕Ор╕Вр╕нр╕Зр╣Вр╕нр╕лр╣Мр╕б:**
$$V = I \times R$$

**р╕кр╕│р╕лр╕гр╕▒р╕Ъ LED Circuit:**
$$R = \frac{V_{supply} - V_{LED}}{I_{LED}}$$

**р╣Бр╕Чр╕Щр╕Др╣Ир╕▓р╕Ир╕гр╕┤р╕З (LED р╕кр╕╡р╣Бр╕Фр╕З + R 470╬й):**
$$I_{actual} = \frac{3.3V - 1.7V}{470\Omega} = \frac{1.6V}{470\Omega} = 3.40mA \text{ тЬЕ р╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕в}$$

**р╕Бр╕│р╕ер╕▒р╕Зр╕Зр╕▓р╕Щр╕Чр╕╡р╣Ир╕кр╕╣р╕Нр╣Ар╕кр╕╡р╕вр╕Чр╕╡р╣И Resistor:**
$$P_R = I^2 \times R = (0.0034)^2 \times 470 = 0.0054W = 5.4mW$$

**р╕Бр╕│р╕ер╕▒р╕Зр╕Зр╕▓р╕Щр╕Чр╕╡р╣И LED р╣Гр╕Кр╣Й:**
$$P_{LED} = V_{LED} \times I = 1.7V \times 0.0034A = 0.0058W = 5.8mW$$
 

#### тЪб PWM р╣Бр╕ер╕░ Timing р╕Бр╕▓р╕гр╕Др╕│р╕Щр╕зр╕У

**р╕Др╕зр╕▓р╕бр╕Цр╕╡р╣Ир╣Гр╕Щр╕Бр╕▓р╕гр╕Бр╕░р╕Юр╕гр╕┤р╕Ъ:**
$$f = \frac{1}{T} = \frac{1}{2 \times \text{delay}} = \frac{1}{2 \times 1000ms} = 0.5Hz$$

**Duty Cycle (р╕лр╕▓р╕Б LED р╣Ар╕Ыр╕┤р╕Ф 70% р╕Вр╕нр╕Зр╣Ар╕зр╕ер╕▓):**
$$\text{Duty Cycle} = \frac{T_{ON}}{T_{ON} + T_{OFF}} \times 100\% = \frac{700ms}{1000ms} \times 100\% = 70\%$$

**р╕Бр╕гр╕░р╣Бр╕кр╣Ар╕Йр╕ер╕╡р╣Ир╕вр╕кр╕│р╕лр╕гр╕▒р╕Ъ PWM:**
$$I_{avg} = I_{peak} \times \frac{\text{Duty Cycle}}{100\%} = 3.40mA \times \frac{50\%}{100\%} = 1.70mA$$

**р╕нр╕▓р╕вр╕╕р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ LED (р╕Ыр╕гр╕░р╕бр╕▓р╕Ур╕Бр╕▓р╕г):**
$$\text{Lifetime} \propto \frac{1}{I_{avg}^2} \text{ (р╕вр╕┤р╣Ир╕Зр╕Бр╕гр╕░р╣Бр╕кр╕Щр╣Йр╕нр╕в р╕вр╕┤р╣Ир╕Зр╕нр╕вр╕╣р╣Ир╕Щр╕▓р╕Щ)}$$
 
---


#### ЁЯЫая╕П р╕нр╕╕р╕Ыр╕Бр╕гр╕Ур╣Мр╕Чр╕╡р╣Ир╣Гр╕Кр╣Й

- ESP32 Development Board
- LED (р╕кр╕╡р╣Бр╕Фр╕З)
- Resistor 470╬й
- Breadboard
- Jumper wires

#### ЁЯФМ р╕Бр╕▓р╕гр╕Хр╣Ир╕нр╕зр╕Зр╕Ир╕г

1. **GPIO 2** тЖТ **Resistor 470╬й** тЖТ **LED Anode (+)**
2. **LED Cathode (-)** тЖТ **GND**

![LED Circuit](images/led_circuit.svg)

> **тЪая╕П р╕лр╕бр╕▓р╕вр╣Ар╕лр╕Хр╕╕:** GPIO р╕Вр╕нр╕З ESP32 р╣Гр╕лр╣Йр╕Бр╕гр╕░р╣Бр╕кр╣Др╕Фр╣Йр╕кр╕╣р╕Зр╕кр╕╕р╕Ф 40mA р╕Хр╣Ир╕н pin

---

## ЁЯР│ Docker Environment Setup р╕кр╕│р╕лр╕гр╕▒р╕Ър╕лр╣Йр╕нр╕Зр╕Др╕нр╕бр╕Юр╕┤р╕зр╣Ар╕Хр╕нр╕гр╣Мр╕кр╣Ир╕зр╕Щр╕Бр╕ер╕▓р╕З

### ЁЯОп р╕Ыр╕▒р╕Нр╕лр╕▓р╕Чр╕╡р╣Ир╕Юр╕Ър╕Ър╣Ир╕нр╕в

1. **р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕ер╕З ESP-IDF р╣Гр╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕З** (р╣Ар╕Юр╕гр╕▓р╕░р╕Ир╕░р╕лр╕▓р╕вр╕лр╕ер╕▒р╕Зр╕гр╕╡р╕Ър╕╣р╕Х)
2. **Docker р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╣Ар╕Вр╣Йр╕▓р╕Цр╕╢р╕З Serial Port** р╣Гр╕Щ Windows
3. **р╕Бр╕▓р╕г Flash firmware р╕Ьр╣Ир╕▓р╕Щ Docker** р╕бр╕╡р╕Ыр╕▒р╕Нр╕лр╕▓

### ЁЯТб р╕зр╕┤р╕Шр╕╡р╣Бр╕Бр╣Йр╕Ыр╕▒р╕Нр╕лр╕▓: Hybrid Development Approach

#### ЁЯФз Method 1: Docker р╕кр╕│р╕лр╕гр╕▒р╕Ъ Build + Host р╕кр╕│р╕лр╕гр╕▒р╕Ъ Flash

**1. р╣Гр╕Кр╣Й Docker р╣Ар╕Юр╕╖р╣Ир╕н compile code:**

```bash
# Build р╣Гр╕Щ Docker (р╣Др╕бр╣Ир╕Хр╣Йр╕нр╕Зр╕ер╕З ESP-IDF р╣Гр╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕З)
docker run --rm -v ${PWD}:/project -w /project espressif/idf:v5.1.2 idf.py build
```

**2. р╣Гр╕Кр╣Й esptool р╣Гр╕Щ host р╕кр╕│р╕лр╕гр╕▒р╕Ъ flash:**

```bash
# Download esptool р╣Бр╕Ър╕Ъ standalone (р╣Др╕бр╣Ир╕Хр╣Йр╕нр╕Зр╕ер╕З Python environment)
# р╕Фр╕▓р╕зр╕Щр╣Мр╣Вр╕лр╕ер╕Фр╕Ир╕▓р╕Б: https://github.com/espressif/esptool/releases
# р╕лр╕гр╕╖р╕нр╣Гр╕Кр╣Й pip install esptool р╣Гр╕Щ user environment

# Flash firmware
esptool.py --chip esp32 --port COM3 --baud 921600 write_flash 0x10000 build/your_project.bin
```

#### ЁЯФз Method 2: Docker with USB Device Passthrough (Windows)

**р╕кр╕│р╕лр╕гр╕▒р╕Ъ Windows + Docker Desktop:**

```yaml
# docker-compose.yml
version: '3.8'
services:
  esp-idf:
    image: espressif/idf:v5.1.2
    volumes:
      - .:/project
    working_dir: /project
    devices:
      - /dev/ttyUSB0:/dev/ttyUSB0  # р╕кр╕│р╕лр╕гр╕▒р╕Ъ Linux
    # Windows р╕Хр╣Йр╕нр╕Зр╣Гр╕Кр╣Й WSL2 р╣Бр╕ер╕░ usbipd-win
    privileged: true
    command: /bin/bash
```

**р╕кр╕│р╕лр╕гр╕▒р╕Ъ Windows 10/11 + WSL2:**

```bash
# 1. р╕ер╕З usbipd-win р╣Гр╕Щ Windows host
winget install usbipd

# 2. р╕Фр╕╣ USB devices
usbipd wsl list

# 3. Attach ESP32 р╣Др╕Ы WSL2
usbipd wsl attach --busid 4-2 --distribution Ubuntu

# 4. р╕гр╕▒р╕Щ Docker р╣Гр╕Щ WSL2
docker run --rm -v ${PWD}:/project --device=/dev/ttyUSB0 espressif/idf:v5.1.2
```

#### ЁЯФз Method 3: Web-based Development (р╣Бр╕Щр╕░р╕Щр╕│р╕кр╕│р╕лр╕гр╕▒р╕Ър╕лр╣Йр╕нр╕Зр╣Ар╕гр╕╡р╕вр╕Щ)

**р╣Гр╕Кр╣Й GitHub Codespaces р╕лр╕гр╕╖р╕н Gitpod:**

```yaml
# .gitpod.yml
image: espressif/idf:v5.1.2
tasks:
  - init: echo "ESP-IDF environment ready"
    command: idf.py --version

vscode:
  extensions:
    - espressif.esp-idf-extension
```

**Workflow:**

1. р╕Щр╕▒р╕Бр╕ир╕╢р╕Бр╕йр╕▓р╣Гр╕Кр╣Й web browser р╣Ар╕Вр╣Йр╕▓ Codespaces
2. Develop р╣Бр╕ер╕░ build р╣Гр╕Щ cloud
3. Download firmware file
4. р╣Гр╕Кр╣Й **ESP32 Flash Tool** (GUI) р╕Ър╕Щ Windows р╣Ар╕Юр╕╖р╣Ир╕н flash

#### ЁЯЫая╕П Quick Solution: Portable ESP32 Flash Tool

**р╕Фр╕▓р╕зр╕Щр╣Мр╣Вр╕лр╕ер╕Ф tools р╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕Хр╣Йр╕нр╕Зр╕ер╕З:**

```text
ЁЯУБ ESP32-Lab-Tools/           (Portable folder р╕кр╕│р╕лр╕гр╕▒р╕Ър╕лр╣Йр╕нр╕Зр╣Ар╕гр╕╡р╕вр╕Щ)
тФЬтФАтФА esptool.exe              (Standalone executable)
тФЬтФАтФА esp32_flash_tool.exe     (GUI tool)
тФЬтФАтФА drivers/                 (CP210x/CH340 drivers)
тФФтФАтФА README.txt               (р╕зр╕┤р╕Шр╕╡р╣Гр╕Кр╣Й)
```

**р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ:**

1. р╣Бр╕Хр╕Бр╣Др╕Яр╕ер╣Мр╕ер╕З USB flash drive
2. р╣Ар╕кр╕╡р╕вр╕Ъ ESP32 р╣Ар╕Вр╣Йр╕▓р╕Др╕нр╕бр╕Юр╕┤р╕зр╣Ар╕Хр╕нр╕гр╣М
3. р╕гр╕▒р╕Щ `esp32_flash_tool.exe`
4. р╣Ар╕ер╕╖р╕нр╕Бр╣Др╕Яр╕ер╣М .bin р╣Бр╕ер╕░ flash

### ЁЯОУ р╣Бр╕Щр╕░р╕Щр╕│р╕кр╕│р╕лр╕гр╕▒р╕Ър╕лр╣Йр╕нр╕Зр╣Ар╕гр╕╡р╕вр╕Щ

#### ЁЯеЗ **Method 1 (р╣Бр╕Щр╕░р╕Щр╕│р╕Чр╕╡р╣Ир╕кр╕╕р╕Ф): Docker Build + Portable Flash Tool**

**р╕Вр╣Йр╕нр╕Фр╕╡:**

- р╣Др╕бр╣Ир╕Хр╣Йр╕нр╕Зр╕ер╕Зр╕нр╕░р╣Др╕гр╣Гр╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕З (Docker pull image р╕Др╕гр╕▒р╣Йр╕Зр╣Ар╕Фр╕╡р╕вр╕з)
- Flash tool р╣Ар╕Ыр╣Зр╕Щ portable executable
- р╕Щр╕▒р╕Бр╕ир╕╢р╕Бр╕йр╕▓р╕кр╕▓р╕бр╕▓р╕гр╕Цр╣Ар╕нр╕▓р╣Др╕Яр╕ер╣Мр╣Др╕Ыр╕Чр╕│р╕Хр╣Ир╕нр╕Чр╕╡р╣Ир╕Ър╣Йр╕▓р╕Щр╣Др╕Фр╣Й

**р╕Вр╕▒р╣Йр╕Щр╕Хр╕нр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Др╕гр╕╣:**

1. р╣Ар╕Хр╕гр╕╡р╕вр╕б USB drive р╕бр╕╡ ESP32 Flash Tool
2. р╕кр╕нр╕Щр╕Щр╕▒р╕Бр╕ир╕╢р╕Бр╕йр╕▓р╣Гр╕Кр╣Й `docker run` command
3. Flash р╕Фр╣Йр╕зр╕в GUI tool

#### ЁЯеИ **Method 3 (р╕кр╕│р╕лр╕гр╕▒р╕Ър╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕╡ Docker): Web-based**

**р╕Вр╣Йр╕нр╕Фр╕╡:**

- р╣Гр╕Кр╣Йр╣Бр╕Др╣И web browser
- р╣Др╕бр╣Ир╕Хр╣Йр╕нр╕Зр╕ер╕Зр╕нр╕░р╣Др╕гр╣Ар╕ер╕в
- Code р╣Ар╕Бр╣Зр╕Ър╣Гр╕Щ cloud (sync across devices)

**р╕Вр╣Йр╕нр╣Ар╕кр╕╡р╕в:**

- р╕Хр╣Йр╕нр╕Зр╕бр╕╡ internet
- р╕Хр╣Йр╕нр╕Зр╕бр╕╡ GitHub account

#### ЁЯПЖ **Hybrid Workflow р╕кр╕│р╕лр╕гр╕▒р╕Ър╕лр╣Йр╕нр╕Зр╣Ар╕гр╕╡р╕вр╕Щ:**

```mermaid
graph TD
    A[р╕Щр╕▒р╕Бр╕ир╕╢р╕Бр╕йр╕▓р╣Ар╕Вр╕╡р╕вр╕Щ Code] --> B[Docker Build]
    B --> C[Download .bin file]
    C --> D[р╣Гр╕Кр╣Й Portable Flash Tool]
    D --> E[Flash р╕ер╕З ESP32]
    E --> F[Test р╕Ър╕Щ Hardware]
    F --> G[р╕Бр╕ер╕▒р╕Ър╣Др╕Ыр╣Бр╕Бр╣Й Code]
    G --> A
```

**р╣Др╕Яр╕ер╣Мр╕Чр╕╡р╣Ир╕Др╕гр╕╣р╕Хр╣Йр╕нр╕Зр╣Ар╕Хр╕гр╕╡р╕вр╕б:**

```text
ЁЯУБ ESP32-Lab-Kit/
тФЬтФАтФА ЁЯР│ docker-commands.txt          (р╕Др╕│р╕кр╕▒р╣Ир╕З Docker р╕Чр╕╡р╣Ир╣Гр╕Кр╣Йр╕Ър╣Ир╕нр╕в)
тФЬтФАтФА ЁЯУ▒ esp32-flash-tool.exe         (Portable flashing tool)
тФЬтФАтФА ЁЯФз cp210x-driver.exe           (Driver р╕кр╕│р╕лр╕гр╕▒р╕Ъ ESP32)
тФЬтФАтФА ЁЯУЪ lab-templates/               (Template projects)
тФВ   тФЬтФАтФА 01-blink/
тФВ   тФЬтФАтФА 02-gpio/
тФВ   тФФтФАтФА 03-pwm/
тФФтФАтФА ЁЯУЦ README.md                   (р╕зр╕┤р╕Шр╕╡р╣Гр╕Кр╣Йр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Щр╕▒р╕Бр╕ир╕╢р╕Бр╕йр╕▓)
```

---

### ЁЯУК GPIO Control Data Flow

![GPIO Data Flow](images/esp32_system_overview.svg)




#### ЁЯФД р╕Вр╕▒р╣Йр╕Щр╕Хр╕нр╕Щр╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щ: User Code тЖТ LED


**р╕гр╕▓р╕вр╕ер╕░р╣Ар╕нр╕╡р╕вр╕Фр╣Бр╕Хр╣Ир╕ер╕░р╕Вр╕▒р╣Йр╕Щр╕Хр╕нр╕Щ:**

1. **User Code** - р╣Ар╕гр╕╡р╕вр╕Б `gpio_set_level(GPIO_NUM_2, 1)`
2. **ESP-IDF** - GPIO driver р╣Бр╕Ыр╕ер╕Зр╣Ар╕Ыр╣Зр╕Щ register operations
3. **Bus Matrix** - р╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Бр╕▓р╕гр╣Ар╕Вр╣Йр╕▓р╕Цр╕╢р╕З peripheral registers (AHB/APB bus)
4. **GPIO Registers** - р╣Ар╕Вр╕╡р╕вр╕Щр╕Др╣Ир╕▓р╕ер╕З GPIO_OUT_REG bit 2
5. **GPIO Matrix** - route digital signal р╣Др╕Ыр╕вр╕▒р╕З physical pin
6. **IO MUX** - р╕Вр╕▒р╕Ър╕кр╕▒р╕Нр╕Нр╕▓р╕Ур╕Чр╕▓р╕Зр╕Бр╕▓р╕вр╕ар╕▓р╕Ю (3.3V/0V)
7. **GPIO2 Pin** - output р╣Бр╕гр╕Зр╕Фр╕▒р╕Щ 3.3V р╕лр╕гр╕╖р╕н 0V
8. **LED Circuit** - LED р╕кр╕зр╣Ир╕▓р╕З/р╕Фр╕▒р╕Ър╕Хр╕▓р╕бр╣Бр╕гр╕Зр╕Фр╕▒р╕Щ (р╕Ьр╣Ир╕▓р╕Щ 470╬й resistor)








### ЁЯТ╗ Lab 1: LED Basic Control (Step by Step)

#### ЁЯОп р╕Бр╕▓р╕гр╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╣Бр╕Ър╕Ър╣Ар╕Ыр╣Зр╕Щр╕Вр╕▒р╣Йр╕Щр╕Хр╕нр╕Щ

**р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в:** р╣Ар╕гр╕┤р╣Ир╕бр╕Ир╕▓р╕Бр╕Зр╣Ир╕▓р╕вр╕Чр╕╡р╣Ир╕кр╕╕р╕Ф тЖТ р╣Др╕Ыр╕Ир╕Щр╕Цр╕╢р╕Зр╕Бр╕▓р╕гр╕Др╕зр╕Ър╕Др╕╕р╕бр╣Бр╕Ър╕Ъ advanced

```text
Step 1: LED ON (р╣Ар╕Вр╣Йр╕▓р╣Гр╕И GPIO basic)
    тЖУ
Step 2: LED OFF (р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╕Бр╕▓р╕гр╕Ыр╕┤р╕Ф LED)
    тЖУ
Step 3: LED Blink (FreeRTOS + р╕зр╕Щр╕ер╕╣р╕Ы)
    тЖУ
Lab 2: PWM Breathing (LEDC + fade effects)
```

#### ЁЯФз Step 1: LED ON - р╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕бр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щр╕Чр╕╡р╣Ир╕кр╕╕р╕Ф

**р╕зр╕▒р╕Хр╕Цр╕╕р╕Ыр╕гр╕░р╕кр╕Зр╕Др╣М:** р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╕Бр╕▓р╕г initialize GPIO р╣Бр╕ер╕░р╣Ар╕Ыр╕┤р╕Ф LED

```c
#include "driver/gpio.h"
#include "esp_log.h"

#define LED_GPIO GPIO_NUM_2

void app_main(void) {
    // р╕Бр╕│р╕лр╕Щр╕Ф GPIO 2 р╣Ар╕Ыр╣Зр╕Щ output
    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);
    
    // р╣Ар╕Ыр╕┤р╕Ф LED (HIGH = 3.3V)
    gpio_set_level(LED_GPIO, 1);
    
    ESP_LOGI("LED", "LED is ON!");
    
    // р╕Ыр╣Йр╕нр╕Зр╕Бр╕▒р╕Щр╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕бр╕Ир╕Ър╕Чр╕▒р╕Щр╕Чр╕╡ (р╕гр╕н forever)
    while(1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

**р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М:** LED р╕Ир╕░р╕кр╕зр╣Ир╕▓р╕Зр╣Бр╕ер╕░р╣Ар╕Ыр╕┤р╕Фр╕Др╣Йр╕▓р╕Зр╣Др╕зр╣Й

---

#### ЁЯФз Step 2: LED OFF - р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╕Бр╕▓р╕гр╕Ыр╕┤р╕Ф LED

**р╕зр╕▒р╕Хр╕Цр╕╕р╕Ыр╕гр╕░р╕кр╕Зр╕Др╣М:** р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕Бр╕▓р╕гр╕Ыр╕┤р╕Ф LED

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"

#define LED_GPIO GPIO_NUM_2

void app_main(void) {
    // р╕Бр╕│р╕лр╕Щр╕Ф GPIO 2 р╣Ар╕Ыр╣Зр╕Щ output
    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);
    
    // р╣Ар╕Ыр╕┤р╕Ф LED р╕Бр╣Ир╕нр╕Щ (HIGH = 3.3V)
    gpio_set_level(LED_GPIO, 1);
    ESP_LOGI("LED", "LED is ON for 3 seconds...");
    
    // р╕гр╕н 3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡
    vTaskDelay(pdMS_TO_TICKS(3000));
    
    // р╕Ыр╕┤р╕Ф LED (LOW = 0V)
    gpio_set_level(LED_GPIO, 0);
    ESP_LOGI("LED", "LED is OFF!");
    
    // р╕Ыр╣Йр╕нр╕Зр╕Бр╕▒р╕Щр╣Вр╕Ыр╕гр╣Бр╕Бр╕гр╕бр╕Ир╕Ър╕Чр╕▒р╕Щр╕Чр╕╡ (р╕гр╕н forever)
    while(1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

**р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М:** LED р╕Ир╕░р╕Хр╕┤р╕Ф 3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡р╣Бр╕ер╣Йр╕зр╕Фр╕▒р╕Ъ

---

#### ЁЯФз Step 3: LED Blink - р╕Бр╕▓р╕гр╕Др╕зр╕Ър╕Др╕╕р╕бр╣Бр╕Ър╕Ър╕зр╕Щр╕ер╕╣р╕Ы

**р╕зр╕▒р╕Хр╕Цр╕╕р╕Ыр╕гр╕░р╕кр╕Зр╕Др╣М:** р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Й FreeRTOS delay р╣Бр╕ер╕░ infinite loop

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"

#define LED_GPIO GPIO_NUM_2
#define BLINK_PERIOD 1000  // 1 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡

void app_main(void) {
    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);
    
    bool led_state = false;
    
    while (1) {
        // р╕кр╕ер╕▒р╕Ър╕кр╕Цр╕▓р╕Щр╕░ LED
        led_state = !led_state;
        gpio_set_level(LED_GPIO, led_state);
        
        ESP_LOGI("LED", "LED is %s", led_state ? "ON" : "OFF");
        
        // р╕лр╕Щр╣Ир╕зр╕Зр╣Ар╕зр╕ер╕▓ 1 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡
        vTaskDelay(pdMS_TO_TICKS(BLINK_PERIOD));
    }
}
```

**р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М:** LED р╕Ир╕░р╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ър╕Чр╕╕р╕Б 1 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡

---

## ЁЯМЯ Lab 2: PWM Breathing Effect

### ЁЯОп р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в: LED р╕лр╕▓р╕вр╣Гр╕Ир╣Ар╕Вр╣Йр╕▓-р╕нр╕нр╕Бр╣Бр╕Ър╕Ър╕Щр╕╕р╣Ир╕бр╕Щр╕зр╕е

**р╣Бр╕Щр╕зр╕Др╕┤р╕Ф:** р╣Гр╕Кр╣Й PWM р╕Ыр╕гр╕▒р╕Ър╕Др╕зр╕▓р╕бр╕кр╕зр╣Ир╕▓р╕Зр╣Бр╕Ър╕Ър╕Др╣Ир╕нр╕вр╣Ар╕Ыр╣Зр╕Щр╕Др╣Ир╕нр╕вр╣Др╕Ы р╣Ар╕ер╕╡р╕вр╕Щр╣Бр╕Ър╕Ър╕Бр╕▓р╕гр╕лр╕▓р╕вр╣Гр╕И

### тЪб PWM Theory

**PWM (Pulse Width Modulation):**
$$\text{Brightness} \propto \text{Duty Cycle} = \frac{T_{ON}}{T_{PERIOD}} \times 100\%$$

**р╕Бр╕▓р╕гр╕Др╕│р╕Щр╕зр╕У PWM Resolution:**
$$\text{Steps} = 2^{\text{Resolution}} = 2^{13} = 8192 \text{ levels}$$

**р╕Др╕зр╕▓р╕бр╕Цр╕╡р╣И PWM:**
$$f_{PWM} = \frac{\text{Clock}}{2^{\text{Resolution}} \times \text{Prescaler}} = \frac{80MHz}{8192 \times 1} = 9.76kHz$$

#### ЁЯФз Step 4: PWM Breathing Implementation

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"

#define LED_GPIO        GPIO_NUM_2
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_CHANNEL    LEDC_CHANNEL_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT  // 8192 levels
#define LEDC_FREQUENCY  5000               // 5kHz
#define FADE_TIME       3000               // 3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡

static const char *TAG = "PWM_BREATHING";

void ledc_init(void) {
    // Configure timer
    ledc_timer_config_t ledc_timer = {
        .duty_resolution = LEDC_DUTY_RES,
        .freq_hz = LEDC_FREQUENCY,
        .speed_mode = LEDC_MODE,
        .timer_num = LEDC_TIMER,
        .clk_cfg = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));

    // Configure channel
    ledc_channel_config_t ledc_channel = {
        .channel    = LEDC_CHANNEL,
        .duty       = 0,
        .gpio_num   = LED_GPIO,
        .speed_mode = LEDC_MODE,
        .hpoint     = 0,
        .timer_sel  = LEDC_TIMER,
    };
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel));
    
    // Initialize fade service
    ESP_ERROR_CHECK(ledc_fade_func_install(0));
}

void app_main(void) {
    ESP_LOGI(TAG, "Starting PWM Breathing Effect");
    
    // Initialize PWM
    ledc_init();
    
    while (1) {
        // р╕лр╕▓р╕вр╣Гр╕Ир╣Ар╕Вр╣Йр╕▓ (Fade IN: 0% тЖТ 100%)
        ESP_LOGI(TAG, "Breathing IN...");
        ESP_ERROR_CHECK(ledc_set_fade_with_time(LEDC_MODE, 
            LEDC_CHANNEL, 8191, FADE_TIME));
        ESP_ERROR_CHECK(ledc_fade_start(LEDC_MODE, 
            LEDC_CHANNEL, LEDC_FADE_WAIT_DONE));
        
        // р╕лр╕▓р╕вр╣Гр╕Ир╕нр╕нр╕Б (Fade OUT: 100% тЖТ 0%)
        ESP_LOGI(TAG, "Breathing OUT...");
        ESP_ERROR_CHECK(ledc_set_fade_with_time(LEDC_MODE, 
            LEDC_CHANNEL, 0, FADE_TIME));
        ESP_ERROR_CHECK(ledc_fade_start(LEDC_MODE, 
            LEDC_CHANNEL, LEDC_FADE_WAIT_DONE));
    }
}
```

**р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М:** LED р╕Ир╕░р╕Др╣Ир╕нр╕вр╣Ж р╕кр╕зр╣Ир╕▓р╕Зр╕Вр╕╢р╣Йр╕Щ (3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡) р╣Бр╕ер╣Йр╕зр╕Др╣Ир╕нр╕вр╣Ж р╕бр╕╖р╕Фр╕ер╕З (3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡) р╕зр╕Щр╕ер╕╣р╕Ыр╣Др╕Ыр╣Ар╕гр╕╖р╣Ир╕нр╕вр╣Ж

#### я┐╜ PWM Breathing Analysis

**р╕Бр╕▓р╕гр╕Др╕│р╕Щр╕зр╕У Breathing Pattern:**
$$\text{Duty}(t) = \frac{8191}{2} \times (1 + \sin(\frac{2\pi t}{T_{period}}))$$

**р╣Вр╕Фр╕вр╕Чр╕╡р╣И:**

- $T_{period} = 6$ р╕зр╕┤р╕Щр╕▓р╕Чр╕╡ (3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡ р╣Ар╕Вр╣Йр╕▓ + 3 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡ р╕нр╕нр╕Б)
- $\text{Duty}(t)$ = р╕Др╣Ир╕▓ duty cycle р╕У р╣Ар╕зр╕ер╕▓ $t$
- р╕Кр╣Ир╕зр╕З duty: 0 р╕Цр╕╢р╕З 8191 (13-bit resolution)

**р╕Бр╕гр╕░р╣Бр╕кр╣Ар╕Йр╕ер╕╡р╣Ир╕вр╣Гр╕Щр╣Вр╕лр╕бр╕Ф Breathing:**
$$I_{avg} = I_{peak} \times \frac{1}{T} \int_0^T \frac{\text{Duty}(t)}{8191} dt = \frac{I_{peak}}{2} = 1.70mA$$

---

### ЁЯОУ Lab Summary

| Step | Lab | Objective | Key Learning |
|------|-----|-----------|--------------|
| **Step 1** | **Lab 1.1** | LED ON | GPIO initialization, basic output |
| **Step 2** | **Lab 1.2** | LED OFF | GPIO control, digital LOW |
| **Step 3** | **Lab 1.3** | LED Blink | FreeRTOS delay, infinite loops |
| **Lab 2** | **PWM Lab** | PWM Breathing | PWM/LEDC, fade effects, analog-like control |

### ЁЯФД Learning Progression

```text
Lab 1: Digital GPIO Control
тФЬтФАтФА Step 1: Basic GPIO OUTPUT (р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щ)
тФЬтФАтФА Step 2: GPIO State Control (р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Йр╕Бр╕▓р╕гр╕Ыр╕┤р╕Ф)
тФФтФАтФА Step 3: Dynamic Control (р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Й timing + loops)

Lab 2: Analog-like Control  
тФФтФАтФА PWM Breathing (р╣Ар╕гр╕╡р╕вр╕Щр╕гр╕╣р╣Й PWM + smooth transitions)
```

### я┐╜ Complete Implementation Example

```c
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"

// р╕Бр╕│р╕лр╕Щр╕Фр╕Др╣Ир╕▓р╕Др╕Зр╕Чр╕╡р╣И
#define LED_GPIO    GPIO_NUM_2      // р╣Гр╕Кр╣Й GPIO 2
#define BLINK_PERIOD 1000          // 1 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡ (1000ms)

static const char *TAG = "LED_CONTROL";

/**
 * @brief р╕Бр╕│р╕лр╕Щр╕Фр╕Др╣Ир╕▓р╣Ар╕гр╕┤р╣Ир╕бр╕Хр╣Йр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ъ GPIO
 */
void led_init(void) {
    ESP_LOGI(TAG, "Initializing LED on GPIO %d", LED_GPIO);
    
    // 1я╕ПтГг р╕кр╕гр╣Йр╕▓р╕З GPIO configuration structure
    gpio_config_t io_conf = {0};
    
    // 2я╕ПтГг р╕Бр╕│р╕лр╕Щр╕Ф pin р╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╣Гр╕Кр╣Й (bit mask)
    io_conf.pin_bit_mask = (1ULL << LED_GPIO);
    
    // 3я╕ПтГг р╕Бр╕│р╕лр╕Щр╕Фр╣Ар╕Ыр╣Зр╕Щ output mode
    io_conf.mode = GPIO_MODE_OUTPUT;
    
    // 4я╕ПтГг р╕Ыр╕┤р╕Ф pull-up/pull-down (р╣Др╕бр╣Ир╕Ир╕│р╣Ар╕Ыр╣Зр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ъ output)
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    
    // 5я╕ПтГг р╕Ыр╕┤р╕Ф interrupt (р╣Др╕бр╣Ир╣Гр╕Кр╣Йр╣Гр╕Щр╕Бр╕▓р╕гр╕Др╕зр╕Ър╕Др╕╕р╕б LED)
    io_conf.intr_type = GPIO_INTR_DISABLE;
    
    // 6я╕ПтГг Apply configuration
    ESP_ERROR_CHECK(gpio_config(&io_conf));
    
    // 7я╕ПтГг Set initial state (LED OFF)
    gpio_set_level(LED_GPIO, 0);
    
    ESP_LOGI(TAG, "LED initialization completed");
}

/**
 * @brief р╕Др╕зр╕Ър╕Др╕╕р╕б LED (р╣Ар╕Ыр╕┤р╕Ф/р╕Ыр╕┤р╕Ф)
 * @param state: 1 = LED ON, 0 = LED OFF
 */
void led_control(int state) {
    gpio_set_level(LED_GPIO, state);
    ESP_LOGI(TAG, "LED %s", state ? "ON" : "OFF");
}

/**
 * @brief Task р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ъ LED
 */
void led_blink_task(void *pvParameters) {
    int led_state = 0;
    
    while (1) {
        // р╕кр╕ер╕▒р╕Ър╕кр╕Цр╕▓р╕Щр╕░ LED
        led_state = !led_state;
        led_control(led_state);
        
        // р╕лр╕Щр╣Ир╕зр╕Зр╣Ар╕зр╕ер╕▓
        vTaskDelay(pdMS_TO_TICKS(BLINK_PERIOD));
    }
}

/**
 * @brief Main application entry point
 */
void app_main(void) {
    ESP_LOGI(TAG, "ESP32 LED Control Demo Started");
    
    // Initialize LED
    led_init();
    
    // Create LED blink task
    xTaskCreate(
        led_blink_task,          // Function pointer
        "led_blink_task",        // Task name
        2048,                    // Stack size (bytes)
        NULL,                    // Parameters
        5,                       // Priority
        NULL                     // Task handle
    );
    
    ESP_LOGI(TAG, "LED blink task created");
}
```

#### ЁЯФз Step 3: CMakeLists.txt

```cmake
idf_component_register(SRCS "main.c"
                      INCLUDE_DIRS ".")
```

#### ЁЯФз Step 4: Build р╣Бр╕ер╕░ Flash

```bash
# Configure target
idf.py set-target esp32

# Build project
idf.py build

# Flash to ESP32
idf.py flash

# Monitor output
idf.py monitor
```

---

### ЁЯФН Code Analysis

#### ЁЯУЛ р╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щр╕Вр╕нр╕Зр╣Бр╕Хр╣Ир╕ер╕░р╕кр╣Ир╕зр╕Щ

##### 1я╕ПтГг **GPIO Configuration Structure**

```c
gpio_config_t io_conf = {
    .pin_bit_mask = (1ULL << LED_GPIO),  // Select pin
    .mode = GPIO_MODE_OUTPUT,            // Output mode
    .pull_up_en = GPIO_PULLUP_DISABLE,   // No pull-up
    .pull_down_en = GPIO_PULLDOWN_DISABLE, // No pull-down
    .intr_type = GPIO_INTR_DISABLE       // No interrupt
};
```

##### 2я╕ПтГг **Register-Level Operations**

```c
// р╣Ар╕Ър╕╖р╣Йр╕нр╕Зр╕лр╕ер╕▒р╕Зр╕Вр╕нр╕З gpio_set_level()
gpio_set_level(LED_GPIO, 1);  // LED ON
// тЖУ р╕ар╕▓р╕вр╣Гр╕Щр╕Ир╕░р╕Чр╕│:
// REG_WRITE(GPIO_OUT_W1TS_REG, (1 << LED_GPIO));

gpio_set_level(LED_GPIO, 0);  // LED OFF  
// тЖУ р╕ар╕▓р╕вр╣Гр╕Щр╕Ир╕░р╕Чр╕│:
// REG_WRITE(GPIO_OUT_W1TC_REG, (1 << LED_GPIO));
```

##### 3я╕ПтГг **FreeRTOS Task Management**

```c
xTaskCreate(
    led_blink_task,    // Task function
    "led_blink_task",  // Task name (for debugging)
    2048,              // Stack size (sufficient for simple GPIO)
    NULL,              // No parameters passed
    5,                 // Priority (1-25, higher = more priority)
    NULL               // Don't need task handle
);
```

---

### ЁЯУК Expected Output

#### ЁЯЦея╕П Serial Monitor Output

```text
I (320) LED_CONTROL: ESP32 LED Control Demo Started
I (320) LED_CONTROL: Initializing LED on GPIO 2
I (330) LED_CONTROL: LED initialization completed
I (330) LED_CONTROL: LED blink task created
I (340) LED_CONTROL: LED ON
I (1340) LED_CONTROL: LED OFF
I (2340) LED_CONTROL: LED ON
I (3340) LED_CONTROL: LED OFF
...
```

#### ЁЯТб Physical Behavior

- LED р╕Ир╕░р╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ър╕Чр╕╕р╕Б 1 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡
- р╕кр╕Цр╕▓р╕Щр╕░р╕Ир╕░р╣Бр╕кр╕Фр╕Зр╣Гр╕Щ Serial Monitor
- р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Бр╕▓р╕гр╕Хр╣Ир╕нр╕зр╕Зр╕Ир╕гр╕Цр╣Йр╕▓ LED р╣Др╕бр╣Ир╕Чр╕│р╕Зр╕▓р╕Щ

---

## ЁЯЪА Advanced Exercises

### ЁЯФз Exercise 1: Multiple LEDs

р╣Бр╕Бр╣Йр╣Др╕В code р╣Гр╕лр╣Йр╕Др╕зр╕Ър╕Др╕╕р╕б LED 3 р╕Фр╕зр╕Зр╕Юр╕гр╣Йр╕нр╕бр╕Бр╕▒р╕Щ (GPIO 2, 4, 5)

```c
#define LED1_GPIO GPIO_NUM_2
#define LED2_GPIO GPIO_NUM_4  
#define LED3_GPIO GPIO_NUM_5

// TODO: р╣Бр╕Бр╣Йр╣Др╕В led_init() р╣Бр╕ер╕░ led_blink_task()
```
```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"

#define LED1_GPIO   GPIO_NUM_2
#define LED2_GPIO   GPIO_NUM_4
#define LED3_GPIO   GPIO_NUM_5

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT      // 0..8191
#define LEDC_FREQUENCY  5000                    // 5 kHz
#define FADE_TIME_MS    3000

static const char *TAG = "PWM_3LED";

static void ledc_init(void)
{
    // 1) р╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓ Timer
    ledc_timer_config_t tcfg = {
        .speed_mode       = LEDC_MODE,
        .duty_resolution  = LEDC_DUTY_RES,
        .timer_num        = LEDC_TIMER,
        .freq_hz          = LEDC_FREQUENCY,
        .clk_cfg          = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    // 2) р╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓ Channel р╕кр╕│р╕лр╕гр╕▒р╕Ъ LED 3 р╕Фр╕зр╕З
    ledc_channel_config_t ch_cfg[] = {
        { .channel = LEDC_CHANNEL_0, .gpio_num = LED1_GPIO, .speed_mode = LEDC_MODE,
          .duty = 0, .hpoint = 0, .timer_sel = LEDC_TIMER },
        { .channel = LEDC_CHANNEL_1, .gpio_num = LED2_GPIO, .speed_mode = LEDC_MODE,
          .duty = 0, .hpoint = 0, .timer_sel = LEDC_TIMER },
        { .channel = LEDC_CHANNEL_2, .gpio_num = LED3_GPIO, .speed_mode = LEDC_MODE,
          .duty = 0, .hpoint = 0, .timer_sel = LEDC_TIMER },
    };
    for (size_t i = 0; i < sizeof(ch_cfg)/sizeof(ch_cfg[0]); ++i) {
        ESP_ERROR_CHECK(ledc_channel_config(&ch_cfg[i]));
    }

    // 3) р╣Ар╕Ыр╕┤р╕Фр╣Гр╕Кр╣Й fade service (р╕Ир╕│р╣Ар╕Ыр╣Зр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ъ ledc_set_fade_with_time)
    ESP_ERROR_CHECK(ledc_fade_func_install(0));
}

void app_main(void)
{
    ESP_LOGI(TAG, "Start 3-LED breathing");
    ledc_init();

    while (1) {
        // Fade IN: 0 -> 8191
        for (ledc_channel_t ch = LEDC_CHANNEL_0; ch <= LEDC_CHANNEL_2; ch++) {
            ESP_ERROR_CHECK(ledc_set_fade_with_time(LEDC_MODE, ch, 8191, FADE_TIME_MS));
            ESP_ERROR_CHECK(ledc_fade_start(LEDC_MODE, ch, LEDC_FADE_NO_WAIT));
        }
        vTaskDelay(pdMS_TO_TICKS(FADE_TIME_MS + 20));  // р╕Бр╕▒р╕Щр╣Ар╕зр╕ер╕▓р╣Др╕бр╣Ир╕Юр╕нр╣Ар╕ер╣Зр╕Бр╕Щр╣Йр╕нр╕в

        // Fade OUT: 8191 -> 0
        for (ledc_channel_t ch = LEDC_CHANNEL_0; ch <= LEDC_CHANNEL_2; ch++) {
            ESP_ERROR_CHECK(ledc_set_fade_with_time(LEDC_MODE, ch, 0, FADE_TIME_MS));
            ESP_ERROR_CHECK(ledc_fade_start(LEDC_MODE, ch, LEDC_FADE_NO_WAIT));
        }
        vTaskDelay(pdMS_TO_TICKS(FADE_TIME_MS + 20));
    }
}
```


https://github.com/user-attachments/assets/eeb009d5-1de1-4647-8e69-b052d601ca1b


### ЁЯФз Exercise 2: LED Patterns

р╕кр╕гр╣Йр╕▓р╕Зр╕гр╕╣р╕Ыр╣Бр╕Ър╕Ър╕Бр╕▓р╕гр╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ъ:

- **Knight Rider (р╕зр╕┤р╣Ир╕Зр╣Др╕Ыр╕бр╕▓)** - LED р╣Ар╕Др╕ер╕╖р╣Ир╕нр╕Щр╕Чр╕╡р╣Ир╣Др╕Ыр╕бр╕▓
 ```c
   #include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT
#define LEDC_FREQUENCY  5000
#define MAX_DUTY        ((1 << 13) - 1)

#define LED_COUNT 3
static const int LED_GPIO[LED_COUNT] = {
    GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_5
};

#define STEP_DELAY_MS 150   // р╕Др╕зр╕▓р╕бр╣Ар╕гр╣Зр╕зр╕Бр╕▓р╕гр╕зр╕┤р╣Ир╕З

static const char *TAG = "KITT_BLINK";

static void ledc_init(void)
{
    // Timer
    ledc_timer_config_t tcfg = {
        .speed_mode       = LEDC_MODE,
        .duty_resolution  = LEDC_DUTY_RES,
        .timer_num        = LEDC_TIMER,
        .freq_hz          = LEDC_FREQUENCY,
        .clk_cfg          = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    // Channels р╕кр╕│р╕лр╕гр╕▒р╕Ъ LED р╣Бр╕Хр╣Ир╕ер╕░р╕Фр╕зр╕З
    for (int i = 0; i < LED_COUNT; i++) {
        ledc_channel_config_t ccfg = {
            .channel    = (ledc_channel_t)i,
            .gpio_num   = LED_GPIO[i],
            .speed_mode = LEDC_MODE,
            .duty       = 0,
            .hpoint     = 0,
            .timer_sel  = LEDC_TIMER,
        };
        ESP_ERROR_CHECK(ledc_channel_config(&ccfg));
    }
}

void app_main(void)
{
    ESP_LOGI(TAG, "Start Knight Rider Blink (no fade)");
    ledc_init();

    int pos = 0;   // р╕Хр╕│р╣Бр╕лр╕Щр╣Ир╕З LED р╕Чр╕╡р╣Ир╕Хр╕┤р╕Ф
    int dir = 1;   // +1 = р╣Др╕Ыр╕Вр╕зр╕▓, -1 = р╣Др╕Ыр╕Лр╣Йр╕▓р╕в

    while (1) {
        // р╕Ыр╕┤р╕Ф LED р╕Чр╕╕р╕Бр╕Фр╕зр╕Зр╕Бр╣Ир╕нр╕Щ
        for (int i = 0; i < LED_COUNT; i++) {
            ledc_set_duty(LEDC_MODE, i, 0);
            ledc_update_duty(LEDC_MODE, i);
        }

        // р╣Ар╕Ыр╕┤р╕Ф LED р╕Фр╕зр╕Зр╕Ыр╕▒р╕Ир╕Ир╕╕р╕Ър╕▒р╕Щ
        ledc_set_duty(LEDC_MODE, pos, MAX_DUTY);
        ledc_update_duty(LEDC_MODE, pos);

        vTaskDelay(pdMS_TO_TICKS(STEP_DELAY_MS));

        // р╣Ар╕Ыр╕ер╕╡р╣Ир╕вр╕Щр╕Чр╕┤р╕ир╕Чр╕▓р╕Зр╣Ар╕бр╕╖р╣Ир╕нр╕Цр╕╢р╕Зр╕Вр╕нр╕Ъ
        if (pos == LED_COUNT - 1) dir = -1;
        else if (pos == 0)        dir = 1;

        pos += dir;
    }
}

```


https://github.com/user-attachments/assets/0ec3b375-1c45-4deb-b8aa-332b218a81b0


- **Binary Counter (р╕Щр╕▒р╕Ър╣Ар╕ер╕Вр╕Рр╕▓р╕Щ 2)** - р╣Бр╕кр╕Фр╕Зр╣Ар╕ер╕Вр╕Рр╕▓р╕Щ 2
 ```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT
#define LEDC_FREQ_HZ    5000
#define MAX_DUTY        ((1 << 13) - 1)

#define LED_COUNT 3
static const int LED_GPIO[LED_COUNT] = {
    GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_5
};

#define STEP_DELAY_MS   800   // р╕Др╕зр╕▓р╕бр╣Ар╕гр╣Зр╕зр╕Бр╕▓р╕гр╕Щр╕▒р╕Ъ

static const char *TAG = "BIN_BLINK";

static void ledc_init(void) {
    ledc_timer_config_t tcfg = {
        .speed_mode       = LEDC_MODE,
        .duty_resolution  = LEDC_DUTY_RES,
        .timer_num        = LEDC_TIMER,
        .freq_hz          = LEDC_FREQ_HZ,
        .clk_cfg          = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    for (int i = 0; i < LED_COUNT; i++) {
        ledc_channel_config_t ccfg = {
            .channel    = (ledc_channel_t)i,
            .gpio_num   = LED_GPIO[i],
            .speed_mode = LEDC_MODE,
            .duty       = 0,
            .hpoint     = 0,
            .timer_sel  = LEDC_TIMER,
        };
        ESP_ERROR_CHECK(ledc_channel_config(&ccfg));
    }
}

void app_main(void) {
    ESP_LOGI(TAG, "Binary Counter (Blink)");
    ledc_init();

    int count = 0;
    while (1) {
        for (int i = 0; i < LED_COUNT; i++) {
            int bit = (count >> i) & 0x01;
            int duty = bit ? MAX_DUTY : 0;

            ledc_set_duty(LEDC_MODE, (ledc_channel_t)i, duty);
            ledc_update_duty(LEDC_MODE, (ledc_channel_t)i);
        }
        vTaskDelay(pdMS_TO_TICKS(STEP_DELAY_MS));

        count = (count + 1) % (1 << LED_COUNT);  // р╕Щр╕▒р╕Ър╣Ар╕ер╕Вр╕Рр╕▓р╕Щ 2
    }
}

```


https://github.com/user-attachments/assets/549e17c2-d61b-4a99-abcd-b5703ef447e6


- **Random Blinking** - р╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ър╣Бр╕Ър╕Ър╕кр╕╕р╣Ир╕б
```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"
#include "esp_random.h"

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT
#define LEDC_FREQ_HZ    5000
#define MAX_DUTY        ((1 << 13) - 1)

#define LED_COUNT 3
static const int LED_GPIO[LED_COUNT] = {
    GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_5
};

#define STEP_DELAY_MS   500   // р╕лр╕Щр╣Ир╕зр╕Зр╣Ар╕зр╕ер╕▓р╕лр╕ер╕▒р╕Зр╕кр╕╕р╣Ир╕бр╕гр╕нр╕Ър╕Щр╕╢р╕З

static const char *TAG = "RAND_BLINK";

static void ledc_init(void) {
    ledc_timer_config_t tcfg = {
        .speed_mode       = LEDC_MODE,
        .duty_resolution  = LEDC_DUTY_RES,
        .timer_num        = LEDC_TIMER,
        .freq_hz          = LEDC_FREQ_HZ,
        .clk_cfg          = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    for (int i = 0; i < LED_COUNT; i++) {
        ledc_channel_config_t ccfg = {
            .channel    = (ledc_channel_t)i,
            .gpio_num   = LED_GPIO[i],
            .speed_mode = LEDC_MODE,
            .duty       = 0,
            .hpoint     = 0,
            .timer_sel  = LEDC_TIMER,
        };
        ESP_ERROR_CHECK(ledc_channel_config(&ccfg));
    }
}

void app_main(void) {
    ESP_LOGI(TAG, "Random Blinking (Blink)");
    ledc_init();

    while (1) {
        for (int i = 0; i < LED_COUNT; i++) {
            int bit = esp_random() & 0x01; // р╕кр╕╕р╣Ир╕б 0 р╕лр╕гр╕╖р╕н 1
            int duty = bit ? MAX_DUTY : 0;

            ledc_set_duty(LEDC_MODE, (ledc_channel_t)i, duty);
            ledc_update_duty(LEDC_MODE, (ledc_channel_t)i);
        }
        vTaskDelay(pdMS_TO_TICKS(STEP_DELAY_MS));
    }
}

```


https://github.com/user-attachments/assets/3c414289-27d3-44e5-8de3-f6437d1fc6ec


---

### ЁЯФз Exercise 3: LED Patterns р╕Чр╣Йр╕▓р╕Чр╕▓р╕вр╕нр╕╡р╕Бр╕Вр╕▒р╣Йр╕Щ

р╕кр╕гр╣Йр╕▓р╕Зр╕гр╕╣р╕Ыр╣Бр╕Ър╕Ър╕Бр╕▓р╕гр╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ър╣Ар╕лр╕бр╕╖р╕нр╕Щ Exercise 2 р╣Бр╕Хр╣Ир╣Ар╕Ыр╣Зр╕Щр╕Ир╕▒р╕Зр╕лр╕зр╕░р╕Бр╕▓р╕гр╕лр╕▓р╕вр╣Гр╕И

- **Knight Rider (р╕зр╕┤р╣Ир╕Зр╣Др╕Ыр╕бр╕▓)** - LED р╣Ар╕Др╕ер╕╖р╣Ир╕нр╕Щр╕Чр╕╡р╣Ир╣Др╕Ыр╕бр╕▓


https://github.com/user-attachments/assets/b17c7f4b-e68c-48c4-a7c1-8039f6ad2a04

  
```c
  #include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT          // 0..8191
#define LEDC_FREQ_HZ    5000                        // 5 kHz
#define MAX_DUTY        ((1 << 13) - 1)            // 8191

// р╕Ыр╕гр╕▒р╕Ър╣Гр╕лр╣Йр╕Хр╕гр╕Зр╕Вр╕▓р╕Ър╕нр╕гр╣Мр╕Фр╕Др╕╕р╕У
#define LED_COUNT 3
static const int LED_GPIO[LED_COUNT] = {
    GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_5
};

// р╣Ар╕нр╕Яр╣Ар╕Яр╕Бр╕Хр╣М
#define STEP_TIME_MS    150    // р╕Др╕зр╕▓р╕бр╣Ар╕гр╣Зр╕зр╕зр╕┤р╣Ир╕Зр╕Хр╣Ир╕н 1 р╕Хр╕│р╣Бр╕лр╕Щр╣Ир╕З
#define FADE_TIME_MS    140    // р╕Др╕зр╕▓р╕бр╕Щр╕╕р╣Ир╕бр╕Вр╕нр╕Зр╕Бр╕▓р╕гр╣Ар╕Ыр╕ер╕╡р╣Ир╕вр╕Щ (р╕Хр╣Йр╕нр╕З <= STEP_TIME_MS)
#define TRAIL_RATIO     25     // % р╕Др╕зр╕▓р╕бр╕кр╕зр╣Ир╕▓р╕Зр╕Вр╕нр╕Зр╕лр╕ер╕нр╕Фр╕Вр╣Йр╕▓р╕Зр╣Ар╕Др╕╡р╕вр╕З (0тАУ100)

static const char *TAG = "KITT";

static void ledc_init(void)
{
    // Timer
    ledc_timer_config_t tcfg = {
        .speed_mode      = LEDC_MODE,
        .duty_resolution = LEDC_DUTY_RES,
        .timer_num       = LEDC_TIMER,
        .freq_hz         = LEDC_FREQ_HZ,
        .clk_cfg         = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    // Channels
    for (int i = 0; i < LED_COUNT; i++) {
        ledc_channel_config_t ccfg = {
            .channel    = (ledc_channel_t)i,
            .gpio_num   = LED_GPIO[i],
            .speed_mode = LEDC_MODE,
            .duty       = 0,
            .hpoint     = 0,
            .timer_sel  = LEDC_TIMER,
        };
        ESP_ERROR_CHECK(ledc_channel_config(&ccfg));
    }

    // р╣Ар╕Ыр╕┤р╕Ф fade service
    ESP_ERROR_CHECK(ledc_fade_func_install(0));
}

static inline uint32_t pct_to_duty(int pct) {
    if (pct <= 0) return 0;
    if (pct >= 100) return MAX_DUTY;
    return (uint32_t)((MAX_DUTY * (uint64_t)pct) / 100);
}

void app_main(void)
{
    ESP_LOGI(TAG, "Start Knight Rider (3 LEDs)");
    ledc_init();

    const uint32_t duty_main  = MAX_DUTY;                 // р╣Др╕Яр╕лр╕ер╕▒р╕Б 100%
    const uint32_t duty_trail = pct_to_duty(TRAIL_RATIO); // р╣Др╕Яр╕Хр╕▓р╕б % р╕Чр╕╡р╣Ир╕Бр╕│р╕лр╕Щр╕Ф

    int pos = 0;          // р╕Хр╕│р╣Бр╕лр╕Щр╣Ир╕Зр╣Др╕Яр╕лр╕ер╕▒р╕Б (0..LED_COUNT-1)
    int dir = +1;         // р╕Чр╕┤р╕ир╕Чр╕▓р╕З (+1 р╣Др╕Ыр╕Вр╕зр╕▓, -1 р╣Др╕Ыр╕Лр╣Йр╕▓р╕в)

    while (1) {
        // р╕Хр╕▒р╣Йр╕Зр╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕вр╕Др╕зр╕▓р╕бр╕кр╕зр╣Ир╕▓р╕Зр╣Бр╕Хр╣Ир╕ер╕░р╕Фр╕зр╕З (main + trail)
        for (int i = 0; i < LED_COUNT; i++) {
            uint32_t target = 0;

            if (i == pos) {
                target = duty_main;
            } else if (i == pos - 1 || i == pos + 1) {
                target = duty_trail;
            } else {
                target = 0;
            }

            ESP_ERROR_CHECK(ledc_set_fade_with_time(
                LEDC_MODE, (ledc_channel_t)i, target, FADE_TIME_MS));
            // р╣Гр╕Кр╣Й NO_WAIT р╣Ар╕Юр╕╖р╣Ир╕н crossfade р╕Юр╕гр╣Йр╕нр╕бр╕Бр╕▒р╕Щ
            ESP_ERROR_CHECK(ledc_fade_start(
                LEDC_MODE, (ledc_channel_t)i, LEDC_FADE_NO_WAIT));
        }

        // р╕гр╕нр╣Гр╕лр╣Йр╕Бр╕▓р╕гр╣Ар╕Яр╕Фр╕гр╕нр╕Ър╕Щр╕╡р╣Йр╣Ар╕Фр╕┤р╕Щр╣Др╕Ыр╕Юр╕нр╣Ар╕лр╕бр╕▓р╕░
        vTaskDelay(pdMS_TO_TICKS(STEP_TIME_MS));

        // р╕Бр╕гр╕░р╕Фр╕нр╕Щр╕Бр╕ер╕▒р╕Ър╣Ар╕бр╕╖р╣Ир╕нр╕Кр╕Щр╕Вр╕нр╕Ъ
        if (pos == LED_COUNT - 1) dir = -1;
        else if (pos == 0)        dir = +1;

        pos += dir;
    }
}
```
- **Binary Counter (р╕Щр╕▒р╕Ър╣Ар╕ер╕Вр╕Рр╕▓р╕Щ 2)** - р╣Бр╕кр╕Фр╕Зр╣Ар╕ер╕Вр╕Рр╕▓р╕Щ 2
  https://github.com/user-attachments/assets/f1428767-deeb-4edf-8ae6-080d96147de8
 ```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT
#define LEDC_FREQ_HZ    5000
#define MAX_DUTY        ((1 << 13) - 1)

#define LED_COUNT 3
static const int LED_GPIO[LED_COUNT] = {
    GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_5
};

#define STEP_DELAY_MS   800   // р╕Др╕зр╕▓р╕бр╣Ар╕гр╣Зр╕зр╕Бр╕▓р╕гр╕Щр╕▒р╕Ъ
#define FADE_TIME_MS    600   // р╣Ар╕зр╕ер╕▓р╕лр╕▓р╕вр╣Гр╕И

static const char *TAG = "BIN_FADE";

static void ledc_init(void) {
    ledc_timer_config_t tcfg = {
        .speed_mode       = LEDC_MODE,
        .duty_resolution  = LEDC_DUTY_RES,
        .timer_num        = LEDC_TIMER,
        .freq_hz          = LEDC_FREQ_HZ,
        .clk_cfg          = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    for (int i = 0; i < LED_COUNT; i++) {
        ledc_channel_config_t ccfg = {
            .channel    = (ledc_channel_t)i,
            .gpio_num   = LED_GPIO[i],
            .speed_mode = LEDC_MODE,
            .duty       = 0,
            .hpoint     = 0,
            .timer_sel  = LEDC_TIMER,
        };
        ESP_ERROR_CHECK(ledc_channel_config(&ccfg));
    }

    ESP_ERROR_CHECK(ledc_fade_func_install(0));
}

void app_main(void) {
    ESP_LOGI(TAG, "Binary Counter (Fade)");
    ledc_init();

    int count = 0;
    while (1) {
        for (int i = 0; i < LED_COUNT; i++) {
            int bit = (count >> i) & 0x01;
            int target = bit ? MAX_DUTY : 0;

            ESP_ERROR_CHECK(ledc_set_fade_with_time(
                LEDC_MODE, (ledc_channel_t)i, target, FADE_TIME_MS));
            ESP_ERROR_CHECK(ledc_fade_start(
                LEDC_MODE, (ledc_channel_t)i, LEDC_FADE_NO_WAIT));
        }
        vTaskDelay(pdMS_TO_TICKS(STEP_DELAY_MS));

        count = (count + 1) % (1 << LED_COUNT);  // р╕Щр╕▒р╕Ър╣Ар╕ер╕Вр╕Рр╕▓р╕Щ 2
    }
}

```


- **Random Blinking** - р╕Бр╕гр╕░р╕Юр╕гр╕┤р╕Ър╣Бр╕Ър╕Ър╕кр╕╕р╣Ир╕б

 

https://github.com/user-attachments/assets/b392afc8-666a-4927-826b-f9bdfcc0b227

 
```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/ledc.h"
#include "esp_log.h"
#include "esp_random.h"

#define LEDC_MODE       LEDC_LOW_SPEED_MODE
#define LEDC_TIMER      LEDC_TIMER_0
#define LEDC_DUTY_RES   LEDC_TIMER_13_BIT
#define LEDC_FREQ_HZ    5000
#define MAX_DUTY        ((1 << 13) - 1)

#define LED_COUNT 3
static const int LED_GPIO[LED_COUNT] = {
    GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_5
};

#define STEP_DELAY_MS   500   // р╕лр╕Щр╣Ир╕зр╕Зр╣Ар╕зр╕ер╕▓р╕лр╕ер╕▒р╕Зр╕кр╕╕р╣Ир╕бр╕гр╕нр╕Ър╕Щр╕╢р╕З
#define FADE_TIME_MS    400   // р╣Ар╕зр╕ер╕▓ fade

static const char *TAG = "RAND_FADE";

static void ledc_init(void) {
    ledc_timer_config_t tcfg = {
        .speed_mode       = LEDC_MODE,
        .duty_resolution  = LEDC_DUTY_RES,
        .timer_num        = LEDC_TIMER,
        .freq_hz          = LEDC_FREQ_HZ,
        .clk_cfg          = LEDC_AUTO_CLK,
    };
    ESP_ERROR_CHECK(ledc_timer_config(&tcfg));

    for (int i = 0; i < LED_COUNT; i++) {
        ledc_channel_config_t ccfg = {
            .channel    = (ledc_channel_t)i,
            .gpio_num   = LED_GPIO[i],
            .speed_mode = LEDC_MODE,
            .duty       = 0,
            .hpoint     = 0,
            .timer_sel  = LEDC_TIMER,
        };
        ESP_ERROR_CHECK(ledc_channel_config(&ccfg));
    }

    ESP_ERROR_CHECK(ledc_fade_func_install(0));
}

void app_main(void) {
    ESP_LOGI(TAG, "Random Blinking (Fade)");
    ledc_init();

    while (1) {
        for (int i = 0; i < LED_COUNT; i++) {
            int bit = esp_random() & 0x01; // р╕кр╕╕р╣Ир╕б 0 р╕лр╕гр╕╖р╕н 1
            int target = bit ? MAX_DUTY : 0;

            ESP_ERROR_CHECK(ledc_set_fade_with_time(
                LEDC_MODE, (ledc_channel_t)i, target, FADE_TIME_MS));
            ESP_ERROR_CHECK(ledc_fade_start(
                LEDC_MODE, (ledc_channel_t)i, LEDC_FADE_NO_WAIT));
        }
        vTaskDelay(pdMS_TO_TICKS(STEP_DELAY_MS));
    }
}



## ЁЯУЪ Additional Resources

### ЁЯФЧ ESP-IDF Documentation

- [GPIO Driver](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/gpio.html)
- [FreeRTOS Tasks](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/freertos.html)

### ЁЯЫая╕П Troubleshooting

- **LED р╣Др╕бр╣Ир╕кр╕зр╣Ир╕▓р╕З:** р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Бр╕▓р╕гр╕Хр╣Ир╕нр╕зр╕Зр╕Ир╕г, р╕Вр╕▒р╣Йр╕зр╕Вр╕нр╕З LED
- **Compile Error:** р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ ESP-IDF environment setup
- **Flash Error:** р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Бр╕▓р╕гр╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕н USB cable

### ЁЯУЦ Reference Materials

- [ESP32-GPIO-Knowledge-Sheet.md](ESP32-GPIO-Knowledge-Sheet.md) - р╕Чр╕др╕йр╕Ор╕╡р╣Ар╕Кр╕┤р╕Зр╕ер╕╢р╕Б
- ESP32 GPIO Pinout р╣Бр╕ер╕░ Constraints
- FreeRTOS Task Programming Guide
```
---

*ЁЯУЕ Created: September 2025*  
*ЁЯСитАНЁЯТ╗ For: ESP32 GPIO Practical Lab*
